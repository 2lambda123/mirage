<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="V1.STACKV4.html">
<link rel="next" href="V1.FS.html">
<link rel="Up" href="V1.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Mirage" rel="Chapter" href="Mirage.html">
<link title="Mirage_misc" rel="Chapter" href="Mirage_misc.html">
<link title="V1" rel="Chapter" href="V1.html">
<link title="V1_LWT" rel="Chapter" href="V1_LWT.html"><title>V1.CHANNEL</title>
</head>
<body>
<div class="navbar"><a class="pre" href="V1.STACKV4.html" title="V1.STACKV4">Previous</a>
&nbsp;<a class="up" href="V1.html" title="V1">Up</a>
&nbsp;<a class="post" href="V1.FS.html" title="V1.FS">Next</a>
</div>
<h1>Module type <a href="type_V1.CHANNEL.html">V1.CHANNEL</a></h1>

<pre><span class="keyword">module type</span> CHANNEL = <code class="code">sig</code> <a href="V1.CHANNEL.html">..</a> <code class="code">end</code></pre><div class="info modtype top">
<h1 id="1_Bufferedbytestream">Buffered byte-stream</h1>
<p>

    Type of a buffered byte-stream that is attached to an unbuffered
    flow (e.g. a TCPv4 connection).<br>
</div>
<hr width="100%">

<pre><span id="TYPEbuffer"><span class="keyword">type</span> <code class="type"></code>buffer</span> </pre>
<div class="info ">
The type for memory buffers.<br>
</div>


<pre><span id="TYPEflow"><span class="keyword">type</span> <code class="type"></code>flow</span> </pre>
<div class="info ">
The type for unbuffered network flow.<br>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
The type for the state associated with channels, such as the
      inflight buffers.<br>
</div>


<pre><span id="TYPEio"><span class="keyword">type</span> <code class="type">+'a</code> io</span> </pre>
<div class="info ">
The type for potentially blocking I/O operation<br>
</div>


<pre><span id="TYPEio_stream"><span class="keyword">type</span> <code class="type">'a</code> io_stream</span> </pre>
<div class="info ">
The type for potentially blocking stream of IO requests.<br>
</div>


<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEflow">flow</a> -> <a href="V1.CHANNEL.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">create flow</code> will allocate send and receive buffers and
      associated them with the given unbuffered <code class="code">flow</code>.<br>
</div>

<pre><span id="VALto_flow"><span class="keyword">val</span> to_flow</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> <a href="V1.CHANNEL.html#TYPEflow">flow</a></code></pre><div class="info ">
<code class="code">to_flow t</code> will return the flow that backs this channel.<br>
</div>

<pre><span id="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> char <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
Read a single character from the channel, blocking if there is
      no immediately available input data.<br>
</div>

<pre><span id="VALread_until"><span class="keyword">val</span> read_until</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> char -> (bool * <a href="V1.CHANNEL.html#TYPEbuffer">buffer</a>) <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">read_until t ch</code> will read from the channel until the given
      <code class="code">ch</code> character is found.  It returns a tuple indicating whether
      the character was found at all (<code class="code">false</code> indicates that an EOF
      condition occurred before the character was encountered), and
      the <code class="code">buffer</code> pointing to the position immediately after the
      character (or the complete scanned buffer if the character was
      never encountered).<br>
</div>

<pre><span id="VALread_some"><span class="keyword">val</span> read_some</span> : <code class="type">?len:int -> <a href="V1.CHANNEL.html#TYPEt">t</a> -> <a href="V1.CHANNEL.html#TYPEbuffer">buffer</a> <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">read_some ?len t</code> will read up to <code class="code">len</code> characters from the
      input channel and at most a full <code class="code">buffer</code>. If <code class="code">len</code> is not
      specified, it will read all available data and return that
      buffer.<br>
</div>

<pre><span id="VALread_stream"><span class="keyword">val</span> read_stream</span> : <code class="type">?len:int -> <a href="V1.CHANNEL.html#TYPEt">t</a> -> <a href="V1.CHANNEL.html#TYPEbuffer">buffer</a> <a href="V1.CHANNEL.html#TYPEio_stream">io_stream</a></code></pre><div class="info ">
<code class="code">read_stream ?len t</code> will return up to <code class="code">len</code> characters as a
      stream of buffers. This call will probably be removed in a
      future revision of the API in favour of <a href="V1.CHANNEL.html#VALread_some"><code class="code">V1.CHANNEL.read_some</code></a>.<br>
</div>

<pre><span id="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> <a href="V1.CHANNEL.html#TYPEbuffer">buffer</a> list <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">read_line t</code> will read a line of input, which is terminated
      either by a CRLF sequence, or the end of the channel (which
      counts as a line).<br>
<b>Returns</b> Returns a list of views that
      terminates at EOF.<br>
</div>

<pre><span id="VALwrite_char"><span class="keyword">val</span> write_char</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> char -> unit</code></pre><div class="info ">
<code class="code">write_char t ch</code> writes a single character to the output
      channel.<br>
</div>

<pre><span id="VALwrite_string"><span class="keyword">val</span> write_string</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> string -> int -> int -> unit</code></pre><div class="info ">
<code class="code">write_string t buf off len</code> writes <code class="code">len</code> bytes from a string
      <code class="code">buf</code>, starting from from offset <code class="code">off</code>.<br>
</div>

<pre><span id="VALwrite_buffer"><span class="keyword">val</span> write_buffer</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> <a href="V1.CHANNEL.html#TYPEbuffer">buffer</a> -> unit</code></pre><div class="info ">
<code class="code">write_buffer t buf</code> will copy the buffer to the channel's
      output buffer.  The buffer should not be modified after being
      written, and it will be recycled into the buffer allocation pool
      at some future point.<br>
</div>

<pre><span id="VALwrite_line"><span class="keyword">val</span> write_line</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> string -> unit</code></pre><div class="info ">
<code class="code">write_line t buf</code> will write the string <code class="code">buf</code> to the output
      channel and append a newline character afterwards.<br>
</div>

<pre><span id="VALflush"><span class="keyword">val</span> flush</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> unit <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">flush t</code> will flush the output buffer and block if necessary
      until it is all written out to the flow.<br>
</div>

<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="V1.CHANNEL.html#TYPEt">t</a> -> unit <a href="V1.CHANNEL.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">close t</code> will call <a href="V1.CHANNEL.html#VALflush"><code class="code">V1.CHANNEL.flush</code></a> and then close the underlying
      flow.<br>
</div>
</body></html>
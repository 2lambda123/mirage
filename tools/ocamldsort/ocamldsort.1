.TH OCAMLDSORT 1

.SH NAME
ocamldsort \- Dependency sorter for OCaml source files

.SH SYNOPSIS

\fBocamldsort\fR [ \fB\-pp\fR \fI pre-command\fR ] [ \fB\-d\fR \fIdep-command\fR ]
           [ \fB\-mli\fR ] [ \fB\-nox\fR ] [ \fB\-obj\fR | \fB\-byte\fR | \fB\-opt\fR ] [ \fIfilename\fR ] \fI...\fR

.SH DESCRIPTION

The
.BR ocamldsort (1)
command scans a set of Objective Caml source files (.ml
and .mli files), sorts them according to their dependencies and prints
the sorted files in order to link their corresponding .cmo files.

For
.BR ocamldsort (1)
to work it must get a list of dependencies generated by
.BR ocamldep (1),
if the standard input to
.BR ocamldsort (1) 
has been redirected
then ocamldsort assumes that this is a dependency file generated by
.BR ocamldep (1).
Otherwise ocamldsort calls
.BR ocamldep (1)
to generate the dependency
list itself. In either case the source files to be sorted should be
given as arguments to the
.BR ocamldsort (1)
command.

.BR ocamldsort (1)
can be used to compile and link simple projects with one
command, such as: 

ocamlc $(ocamldsort *.ml)

if your project
doesn't contain .mli files or:

.cc @
@nf
ocamlc \-c $(ocamldsort \-mli *.ml *.mli) && ocamlc $(ocamldsort \-byte *.ml)
@fi
@cc

if it contains .mli files.

However for larger projects where separate compilation is desirable,
.BR ocamldsort (1)
can also be used from within a makefile. Here is a typical
makefile example:

.cc @
@nf
TARGET=my_program
OCAMLC=ocamlc
OCAMLOPT=ocamlopt
OCAMLDEP=ocamldep
OCAMLDSORT=ocamldsort

PPFLAGS=\-pp camlp4o

MLY=$(shell echo *.mly)
MLL=$(shell echo *.mll)
GENERATED_ML=$(MLY:.mly=.ml) $(MLL:.mll=.ml)

include .generated .depend .ocamldsort

$(TARGET): $(CMO_FILES)
	$(OCAMLC) $(COMPFLAGS) $(LIBS) $^ \-o $@

$(TARGET).opt: $(CMX_FILES)
	$(OCAMLOPT) $(COMPFLAGS) $(LIBS_OPT) $^ \-o $@

.generated: $(GENERATED_ML)
	@touch .generated

.depend: .generated
	$(OCAMLDEP) *.ml *.mli > $@

.ocamldsort: .depend
	echo CMO_FILES=`< .depend $(OCAMLDSORT) \-byte *.ml` > .ocamldsort
	echo CMX_FILES=`< .depend $(OCAMLDSORT) \-opt *.ml` >> .ocamldsort

distclean: clean
	rm \-f .generated .depend .ocamldsort
	rm \-f $(GENERATED_ML)
	rm \-f *~
	rm \-f $(TARGET) 

clean:
	rm \-f *.cmo *.cmi *.cmx *.o 

.SUFFIXES: .mli .ml .cmi .cmo .cmx .mll .mly

%.cmi:%.mli
	$(OCAMLC) $(PPFLAGS) $(COMPFLAGS) \-c $<

%.cmo:%.ml
	$(OCAMLC) $(PPFLAGS) $(COMPFLAGS) \-c $<

%.cmi %.cmo:%.ml
	$(OCAMLC) $(PPFLAGS) $(COMPFLAGS) \-c $<

%.cmx %.o:%.ml
	$(OCAMLOPT) $(PPFLAGS) $(COMPFLAGS) \-c $<

%.ml:%.mll
	$(OCAMLLEX) $<

%.mli %.ml:%.mly
	$(OCAMLYACC) \-v $<
@fi
@cc

.SH OPTIONS

The following command-line options are recognized by 
.BR ocamlsort (1):

.TP
.BI \-I \ directory
Add the given directory to the list of directories searched for
source files.

.TP
.BI \-pp \ pre-command
Command to preprocess file.

.TP
.BI \-d \ dep-command
Command to compute dependencies. 
.BR ocamldep (1)
by default.

.TP
.BI \-mli
Sort files using mli dependencies.

.TP
.BI \-nox
Ignore filenames containg `*' so that unexpanded wildcards are ignored.

.TP
.BI \-obj
Print bytecode filenames (.cmo and .cmi) (deprecated: use \-byte).

.TP
.BI \-byte
Print bytecode filenames (.cmo and .cmi).

.TP
.BI \-opt
Print opt filenames (.cmx and .cmi).

.TP
.BI \-v
Output version information and exit.

.TP
\fB\-help\fR, \fB\-\-help\fR
Output help and exit.

.SH SEE ALSO
.BR ocamldep (1).

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="V1.CLOCK.html">
<link rel="next" href="V1.CONSOLE.html">
<link rel="Up" href="V1.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Mirage" rel="Chapter" href="Mirage.html">
<link title="Mirage_key" rel="Chapter" href="Mirage_key.html">
<link title="Mirage_runtime" rel="Chapter" href="Mirage_runtime.html">
<link title="Mirage_info" rel="Chapter" href="Mirage_info.html">
<link title="V1" rel="Chapter" href="V1.html">
<link title="V1_LWT" rel="Chapter" href="V1_LWT.html"><title>V1.FLOW</title>
</head>
<body>
<div class="navbar"><a class="pre" href="V1.CLOCK.html" title="V1.CLOCK">Previous</a>
&nbsp;<a class="up" href="V1.html" title="V1">Up</a>
&nbsp;<a class="post" href="V1.CONSOLE.html" title="V1.CONSOLE">Next</a>
</div>
<h1>Module type <a href="type_V1.FLOW.html">V1.FLOW</a></h1>

<pre><span class="keyword">module type</span> FLOW = <code class="code"><span class="keyword">sig</span></code> <a href="V1.FLOW.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info modtype top">
<h1 id="1_Connectionbetweenendpoints">Connection between endpoints</h1><br>
</div>
<hr width="100%">

<pre><span id="TYPEio"><span class="keyword">type</span> <code class="type">+'a</code> io</span> </pre>
<div class="info ">
The type for potentially blocking I/O operation<br>
</div>


<pre><span id="TYPEbuffer"><span class="keyword">type</span> <code class="type"></code>buffer</span> </pre>
<div class="info ">
The type for memory buffer.<br>
</div>


<pre><span id="TYPEflow"><span class="keyword">type</span> <code class="type"></code>flow</span> </pre>
<div class="info ">
The type for flows. A flow represents the state of a single
      stream that is connected to an endpoint.<br>
</div>


<pre><span id="TYPEerror"><span class="keyword">type</span> <code class="type"></code>error</span> </pre>
<div class="info ">
The type for errors.<br>
</div>


<pre><span id="VALerror_message"><span class="keyword">val</span> error_message</span> : <code class="type"><a href="V1.FLOW.html#TYPEerror">error</a> -> string</code></pre><div class="info ">
Convert an error to a human-readable message, suitable for
      logging.<br>
</div>

<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type"><a href="V1.FLOW.html#TYPEflow">flow</a> -><br>       [ `Eof | `Error of <a href="V1.FLOW.html#TYPEerror">error</a> | `Ok of <a href="V1.FLOW.html#TYPEbuffer">buffer</a> ] <a href="V1.FLOW.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">read flow</code> blocks until some data is available and returns a
      fresh buffer containing it.
<p>

      The returned buffer will be of a size convenient to the flow
      implementation, but will always have at least 1 byte.
<p>

      If the remote endpoint calls <code class="code">close</code> then calls to <code class="code">read</code> will
      keep returning data until all the in-flight data has been read.
      <code class="code">read flow</code> will return <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code> when the remote endpoint has
      called <code class="code">close</code> and when there is no more in-flight data.<br>
</div>

<pre><span id="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="V1.FLOW.html#TYPEflow">flow</a> -><br>       <a href="V1.FLOW.html#TYPEbuffer">buffer</a> -> [ `Eof | `Error of <a href="V1.FLOW.html#TYPEerror">error</a> | `Ok of unit ] <a href="V1.FLOW.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">write flow buffer</code> writes a buffer to the flow. There is no
      indication when the buffer has actually been read and, therefore,
      it must not be reused.  The contents may be transmitted in
      separate packets, depending on the underlying transport. The
      result <code class="code"><span class="keywordsign">`</span><span class="constructor">Ok</span> ()</code> indicates success, <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code> indicates that the
      connection is now closed and <code class="code"><span class="keywordsign">`</span><span class="constructor">Error</span></code> indicates some other error.<br>
</div>

<pre><span id="VALwritev"><span class="keyword">val</span> writev</span> : <code class="type"><a href="V1.FLOW.html#TYPEflow">flow</a> -><br>       <a href="V1.FLOW.html#TYPEbuffer">buffer</a> list -><br>       [ `Eof | `Error of <a href="V1.FLOW.html#TYPEerror">error</a> | `Ok of unit ] <a href="V1.FLOW.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">writev flow buffers</code> writes a sequence of buffers to the flow.
      There is no indication when the buffers have actually been read and,
      therefore, they must not be reused. The result <code class="code"><span class="keywordsign">`</span><span class="constructor">Ok</span> ()</code> indicates
      success, <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code> indicates that the connection is now closed and
      <code class="code"><span class="keywordsign">`</span><span class="constructor">Error</span></code> indicates some other error.<br>
</div>

<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="V1.FLOW.html#TYPEflow">flow</a> -> unit <a href="V1.FLOW.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">close flow</code> flushes all pending writes and signals the remote
      endpoint that there will be no future writes. Once the remote endpoint
      has read all pending data, it is expected that calls to <code class="code">read</code> on
      the remote return <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code>.
<p>

      Note it is still possible for the remote endpoint to <code class="code">write</code> to
      the flow and for the local endpoint to call <code class="code">read</code>. This state where
      the local endpoint has called <code class="code">close</code> but the remote endpoint
      has not called <code class="code">close</code> is similar to that of a half-closed TCP
      connection or a Unix socket after <code class="code">shutdown(<span class="constructor">SHUTDOWN_WRITE</span>)</code>.
<p>

      <code class="code">close flow</code> waits until the remote endpoint has also called <code class="code">close</code>
      before returning. At this point no data can flow in either direction
      and resources associated with the flow can be freed.<br>
</div>
</body></html>